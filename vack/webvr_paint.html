<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webvr - paint</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Origin Trial Token, feature = WebXR Device API (For Chrome M69+), origin = https://threejs.org, expires = 2019-01-07 -->
    <meta http-equiv="origin-trial" data-feature="WebXR Device API (For Chrome M69+)" data-expires="2019-01-07"
          content="ArPzyYNrUDiXsGOh647Ya7MtVUA1nM+WFMnPWu7eoF2nQHOP6mTATIbiv0w+k2kFaPofZG/04ZEQdsACq4IA0wQAAABTeyJvcmlnaW4iOiJodHRwczovL3RocmVlanMub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZU02OSIsImV4cGlyeSI6MTU0Njg4MzAxOH0=">
    <!-- Origin Trial Token, feature = WebXR Gamepad Support, origin = https://threejs.org, expires = 2019-01-07 -->
    <meta http-equiv="origin-trial" data-feature="WebXR Gamepad Support" data-expires="2019-01-07"
          content="Av16a8LVXasKVQV9j3u0OlXdTfz5O9qDqhROyL5Up6R3sdOPbtFuc6n6o5DHitwnb5VdirH0GyvROwvz8xxd0AkAAABYeyJvcmlnaW4iOiJodHRwczovL3RocmVlanMub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkdhbWVwYWRTdXBwb3J0IiwiZXhwaXJ5IjoxNTQ2ODgzMDE4fQ==">
    <style>
        body {
            font-family: Monospace;
            background-color: #101010;
            color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        a {
            color: #f00;
        }
    </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.js"></script>
<!--<script src="https://threejs.org/examples/js/controls/TrackballControls.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.js"></script>
<script src="js/vr/WebVR.js"></script>

<script src="js/loaders/OBJLoader.js"></script>

<script src="data/gsachs.js"></script>

<script>// these are, as before, to make D3's .append() and .selectAll() work
THREE.Object3D.prototype.appendChild = function (c) {
    this.add(c);
    return c;
};
THREE.Object3D.prototype.querySelectorAll = function () {
    return this.children;
};
THREE.Object3D.prototype.insertBefore = function (newNode, referenceNode) {
    t = newNode;
    if (referenceNode == null) {
        console.log(newNode, referenceNode);
        this.add(newNode);
    } else {
        console.log(newNode, referenceNode);
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
    }
};
// this one is to use D3's .attr() on THREE's objects
THREE.Object3D.prototype.setAttribute = function (name, value) {
    var chain = name.split('.');
    var object = this;
    for (var i = 0; i < chain.length - 1; i++) {
        object = object[chain[i]];
    }
    object[chain[chain.length - 1]] = value;
}
</script>

<script>

    var container;
    var camera, scene, renderer;
    var controller1, controller2;
    var chart3d

    var line;
    var shapes = {};

    var up = new THREE.Vector3(0, 1, 0);

    var vector1 = new THREE.Vector3();
    var vector2 = new THREE.Vector3();
    var vector3 = new THREE.Vector3();
    var vector4 = new THREE.Vector3();

    const sphere = new THREE.Mesh(new THREE.SphereGeometry(1, 32, 32), new THREE.MeshBasicMaterial({color: 0xbada55}));

    init();
    initGeometry();


    animate();


    function init() {

        container = document.createElement('div');
        document.body.appendChild(container);

        var info = document.createElement('div');
        info.style.position = 'absolute';
        info.style.top = '10px';
        info.style.width = '100%';
        info.style.textAlign = 'center';
        info.innerHTML = '<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webvr - paint';
        container.appendChild(info);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

        var geometry = new THREE.BoxBufferGeometry(0.5, 0.8, 0.5);
        var material = new THREE.MeshStandardMaterial({
            color: 0x444444,
            roughness: 1.0,
            metalness: 0.0
        });
        var table = new THREE.Mesh(geometry, material);
        table.position.y = 0.35;
        table.position.z = 0.85;
        table.castShadow = true;
        table.receiveShadow = true;
        // scene.add( table );

        /*
        var table = new THREE.Mesh( geometry, material );
        table.position.y = 0.35;
        table.position.z = -0.85;
        table.castShadow = true;
        table.receiveShadow = true;
        scene.add( table );
        */

        var geometry = new THREE.PlaneBufferGeometry(4, 4);
        var material = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 1.0,
            metalness: 0.0
        });
        var floor = new THREE.Mesh(geometry, material);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        // scene.add( floor );
        //
        // var floor = new THREE.Mesh( geometry, material );
        // // floor.rotation.x = - Math.PI / 2;
        // floor.receiveShadow = true;
        // scene.add( floor );
        //
        // var floor = new THREE.Mesh( geometry, material );
        // floor.rotation.y = - Math.PI / 2;
        // floor.receiveShadow = true;
        // scene.add( floor );

        let gridHelperX = new THREE.GridHelper(20, 40, 0x111111, 0x111111);
        let gridHelperY = new THREE.GridHelper(20, 40, 0x111111, 0x111111);
        let gridHelperZ = new THREE.GridHelper(20, 40, 0x111111, 0x111111);
        gridHelperZ.rotation.x = Math.PI / 2;
        gridHelperY.rotation.z = Math.PI / 2;
        scene.add(gridHelperX);
        scene.add(gridHelperY);
        scene.add(gridHelperZ);

        scene.add(new THREE.HemisphereLight(0x888877, 0x777788));

        var light = new THREE.DirectionalLight(0xffffff);
        light.position.set(0, 6, 0);
        light.castShadow = true;
        light.shadow.camera.top = 2;
        light.shadow.camera.bottom = -2;
        light.shadow.camera.right = 2;
        light.shadow.camera.left = -2;
        light.shadow.mapSize.set(4096, 4096);
        scene.add(light);

        // scene.add( new THREE.DirectionalLightHelper( light ) );
        // scene.add( new THREE.CameraHelper( light.shadow.camera ) );

        //

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.gammaInput = true;
        renderer.gammaOutput = true;
        renderer.shadowMap.enabled = true;
        renderer.vr.enabled = true;
        container.appendChild(renderer.domElement);

        document.body.appendChild(WEBVR.createButton(renderer));

        // controllers

        function onSelectStart() {

            this.userData.isSelecting = true;

        }

        function onSelectEnd() {

            this.userData.isSelecting = false;

        }

        controller1 = renderer.vr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        controller1.userData.points = [new THREE.Vector3(), new THREE.Vector3()];
        controller1.userData.matrices = [new THREE.Matrix4(), new THREE.Matrix4()];
        scene.add(controller1);

        controller2 = renderer.vr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);
        controller2.userData.points = [new THREE.Vector3(), new THREE.Vector3()];
        controller2.userData.matrices = [new THREE.Matrix4(), new THREE.Matrix4()];
        scene.add(controller2);

        var loader = new THREE.OBJLoader();
        loader.setPath('models/obj/vive-controller/');
        loader.load('vr_controller_vive_1_5.obj', function (object) {

            var loader = new THREE.TextureLoader();
            loader.setPath('models/obj/vive-controller/');

            var controller = object.children[0];
            controller.material.map = loader.load('onepointfive_texture.png');
            controller.material.specularMap = loader.load('onepointfive_spec.png');
            controller.castShadow = true;
            controller.receiveShadow = true;

            // var pivot = new THREE.Group();
            // var pivot = new THREE.Mesh( new THREE.BoxBufferGeometry( 0.01, 0.01, 0.01 ) );
            var pivot = new THREE.Mesh(new THREE.IcosahedronBufferGeometry(0.01, 2));
            pivot.name = 'pivot';
            pivot.position.y = -0.016;
            pivot.position.z = -0.043;
            pivot.rotation.x = Math.PI / 5.5;
            controller.add(pivot);

            controller1.add(controller.clone());

            pivot.material = pivot.material.clone();
            controller2.add(controller.clone());

        });

        // scene.add(sphere);
        const ptShape = new THREE.Geometry();
        const ptMaterial = new THREE.PointsMaterial({color: 0xffffff, size: 0.02});

        let maxX, maxY, maxZ;
        for (const [x, y, z] in gsachs) {
            if (x == null || y == null || z == null) {
                continue;
            }

            maxX = Math.max(x, maxX);
            maxY = Math.max(y, maxY);
            maxZ = Math.max(z, maxZ);
        }

        for (let [x, y, z] in gsachs) {
            if (x == null || y == null || z == null) {
                continue;
            }

            x = Math.random();
            y = Math.random();
            z = Math.random() * 10;

            // let mesh = new THREE.Point(ptShape, ptMaterial);
            // scene.add(mesh);
            // mesh.position.x = x;
            // mesh.position.y = y;
            // mesh.position.z = z;
            ptShape.vertices.push(new THREE.Vector3(x, y, z));
        }

        scene.add(new THREE.Points(ptShape, ptMaterial));


        const xAxisMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});
        const yAxisMaterial = new THREE.MeshStandardMaterial({color: 0x00ff00});
        const zAxisMaterial = new THREE.MeshStandardMaterial({color: 0x0000ff});

        const axisGeom = new THREE.CylinderGeometry(0.01, 0.01, 10, 10, 1, true);

        const xAxis = new THREE.Mesh(axisGeom, xAxisMaterial);
        xAxis.rotation.z = Math.PI / 2;
        const yAxis = new THREE.Mesh(axisGeom, yAxisMaterial);
        const zAxis = new THREE.Mesh(axisGeom, zAxisMaterial);
        zAxis.rotation.x = Math.PI / 2;

        scene.add(xAxis);
        scene.add(yAxis);
        scene.add(zAxis);


        var data = [10, 8, 15, 16, 23, 42];
        var t = null;


        // create container for our 3D chart
        chart3d = new THREE.Object3D();
        // chart3d.rotation.x = 0.6;

        // use D3 to set up 3D bars
        var barGraph = d3.select(chart3d)
            .selectAll()
            .data(data);

        barGraph.enter().append(function () {
            var material = new THREE.MeshLambertMaterial({
                color: 0x4682B4, shading: THREE.FlatShading, vertexColors: THREE.VertexColors
            });
            return new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), material);
        })
            // .attr("geometry.parameters.height", function (d, i) {
            //     console.log(this, d, i);
            //     return d;
            // })
            // .attr("geometry.verticesNeedUpdate", () => true)
            .attr("position.x", function (d, i) {
                return i;
            })
            .attr("position.y", function (d, i) {
                return 0;
            })
            .attr("scale.y", function (d, i) {
                return d / 2;
            })
            .attr("material.color.r", function (d, i) {
                return i / 6.0 + 0.1;
            })
            .attr("material.color.g", function (d, i) {
                return i / 3.0 + 0.1;
            })
            .attr("material.color.b", function (d, i) {
                return i / 2.0 + 0.1;
            })

        scene.add(chart3d);

        window.addEventListener('resize', onWindowResize, false);

    }

    function initGeometry() {

        var geometry = new THREE.BufferGeometry();

        var positions = new THREE.BufferAttribute(new Float32Array(1000000 * 3), 3);
        positions.dynamic = true;
        geometry.addAttribute('position', positions);

        var normals = new THREE.BufferAttribute(new Float32Array(1000000 * 3), 3);
        normals.dynamic = true;
        geometry.addAttribute('normal', normals);

        var colors = new THREE.BufferAttribute(new Float32Array(1000000 * 3), 3);
        colors.dynamic = true;
        geometry.addAttribute('color', colors);

        geometry.drawRange.count = 0;

        //

        /*
        var path = "textures/cube/SwedishRoyalCastle/";
        var format = '.jpg';
        var urls = [
            path + 'px' + format, path + 'nx' + format,
            path + 'py' + format, path + 'ny' + format,
            path + 'pz' + format, path + 'nz' + format
        ];

        var reflectionCube = new THREE.CubeTextureLoader().load( urls );
        */

        var material = new THREE.MeshStandardMaterial({
            roughness: 0.9,
            metalness: 0.0,
            // envMap: reflectionCube,
            vertexColors: THREE.VertexColors,
            side: THREE.DoubleSide
        });

        line = new THREE.Mesh(geometry, material);
        line.frustumCulled = false;
        line.castShadow = true;
        line.receiveShadow = true;
        scene.add(line);

        // Shapes
        shapes['tube'] = getTubeShapes(1.0);

    }

    function getTubeShapes(size) {

        var PI2 = Math.PI * 2;

        var sides = 10;
        var array = [];
        var radius = 0.01 * size;

        for (var i = 0; i < sides; i++) {

            var angle = (i / sides) * PI2;
            array.push(new THREE.Vector3(Math.sin(angle) * radius, Math.cos(angle) * radius, 0));

        }

        return array;

    }

    function stroke(controller, point1, point2, matrix1, matrix2) {

        var color = new THREE.Color(0xffffff);
        var size = 1;

        var shapes = getTubeShapes(size);

        var geometry = line.geometry;
        var attributes = geometry.attributes;
        var count = geometry.drawRange.count;

        var positions = attributes.position.array;
        var normals = attributes.normal.array;
        var colors = attributes.color.array;

        for (var j = 0, jl = shapes.length; j < jl; j++) {

            var vertex1 = shapes[j];
            var vertex2 = shapes[(j + 1) % jl];

            // positions

            vector1.copy(vertex1);
            vector1.applyMatrix4(matrix2);
            vector1.add(point2);

            vector2.copy(vertex2);
            vector2.applyMatrix4(matrix2);
            vector2.add(point2);

            vector3.copy(vertex2);
            vector3.applyMatrix4(matrix1);
            vector3.add(point1);

            vector4.copy(vertex1);
            vector4.applyMatrix4(matrix1);
            vector4.add(point1);

            vector1.toArray(positions, (count + 0) * 3);
            vector2.toArray(positions, (count + 1) * 3);
            vector4.toArray(positions, (count + 2) * 3);

            vector2.toArray(positions, (count + 3) * 3);
            vector3.toArray(positions, (count + 4) * 3);
            vector4.toArray(positions, (count + 5) * 3);

            // normals

            vector1.copy(vertex1);
            vector1.applyMatrix4(matrix2);
            vector1.normalize();

            vector2.copy(vertex2);
            vector2.applyMatrix4(matrix2);
            vector2.normalize();

            vector3.copy(vertex2);
            vector3.applyMatrix4(matrix1);
            vector3.normalize();

            vector4.copy(vertex1);
            vector4.applyMatrix4(matrix1);
            vector4.normalize();

            vector1.toArray(normals, (count + 0) * 3);
            vector2.toArray(normals, (count + 1) * 3);
            vector4.toArray(normals, (count + 2) * 3);

            vector2.toArray(normals, (count + 3) * 3);
            vector3.toArray(normals, (count + 4) * 3);
            vector4.toArray(normals, (count + 5) * 3);

            // colors

            color.toArray(colors, (count + 0) * 3);
            color.toArray(colors, (count + 1) * 3);
            color.toArray(colors, (count + 2) * 3);

            color.toArray(colors, (count + 3) * 3);
            color.toArray(colors, (count + 4) * 3);
            color.toArray(colors, (count + 5) * 3);

            count += 6;

        }

        geometry.drawRange.count = count;

    }

    function updateGeometry(start, end) {

        if (start === end) return;

        var offset = start * 3;
        var count = (end - start) * 3;

        var geometry = line.geometry;
        var attributes = geometry.attributes;

        attributes.position.updateRange.offset = offset;
        attributes.position.updateRange.count = count;
        attributes.position.needsUpdate = true;

        attributes.normal.updateRange.offset = offset;
        attributes.normal.updateRange.count = count;
        attributes.normal.needsUpdate = true;

        attributes.color.updateRange.offset = offset;
        attributes.color.updateRange.count = count;
        attributes.color.needsUpdate = true;

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

    }

    function handleController(controller) {

        var pivot = controller.getObjectByName('pivot');

        if (pivot) {

            var matrix = pivot.matrixWorld;

            var point1 = controller.userData.points[0];
            var point2 = controller.userData.points[1];

            var matrix1 = controller.userData.matrices[0];
            var matrix2 = controller.userData.matrices[1];

            point1.setFromMatrixPosition(matrix);
            matrix1.lookAt(point2, point1, up);

            if (controller.userData.isSelecting === true) {

                stroke(controller, point1, point2, matrix1, matrix2);

            }

            point2.copy(point1);
            matrix2.copy(matrix1);

        }

    }

    function animate() {

        renderer.setAnimationLoop(render);

    }

    function render() {

        var count = line.geometry.drawRange.count;

        handleController(controller1);
        handleController(controller2);

        // camera.fov = Math.sin(Date.now() / 500) * 20 + 40;

        updateGeometry(count, line.geometry.drawRange.count);

        for (var i = 0; i < 5; i++) {
            var x = d3.select(chart3d).selectAll()[0][i]
                .material
                .color;
            if (x.goingUp) {
                if (x.r > 1) x.goingUp = 0;
                x.r += .005;
            } else {
                if (x.r < 0) x.goingUp = 1;
                x.r -= .005;
            }
        }
        // d3.select(chart3d).selectAll()
        //     .attr("scale.x", function(d, i) {
        //         console.log(d);
        //         // return d.scale.x += 0.01;
        //         return d;
        //     });
        // requestAnimationFrame( animate );
        chart3d.rotation.y += 0.01;

        renderer.render(scene, camera);

    }

</script>
</body>
</html>
